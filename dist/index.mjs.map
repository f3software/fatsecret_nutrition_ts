{"version":3,"sources":["../src/config/urls.ts","../src/config/platform.ts","../src/http/fetch-http-client.ts","../src/auth/client-credentials.ts","../src/auth/token-cache.ts","../src/auth/oauth1.ts","../src/auth/auth-manager.ts","../src/service/api-service.ts","../src/types/enums.ts","../src/platform/adapters.ts","../src/client.ts"],"names":["FatSecretMethod","FatSecretEndpoint"],"mappings":"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","sourcesContent":["export interface FatSecretEnvironment {\n  apiBaseUrl: string;\n  oauthBaseUrl: string;\n  imageRecognitionUrl: string;\n  naturalLanguageProcessingUrl: string;\n}\n\nexport const FATSECRET_PROD: FatSecretEnvironment = {\n  apiBaseUrl: \"https://platform.fatsecret.com/rest\",\n  oauthBaseUrl: \"https://oauth.fatsecret.com/connect/token\",\n  imageRecognitionUrl:\n    \"https://platform.fatsecret.com/rest/image-recognition/v2\",\n  naturalLanguageProcessingUrl:\n    \"https://platform.fatsecret.com/rest/natural-language-processing/v1\",\n};\n\nexport const DEFAULT_ENVIRONMENT = FATSECRET_PROD;\n","export type PlatformTarget = \"web\" | \"react-native\" | \"node\";\n\nexport interface PlatformConfig {\n  target: PlatformTarget;\n  userAgent?: string;\n}\n\nexport const detectPlatform = (): PlatformTarget => {\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return \"react-native\";\n  }\n  if (typeof window !== \"undefined\") {\n    return \"web\";\n  }\n  return \"node\";\n};\n","import type { HttpClient, HttpRequest, HttpResponse } from \"./http-client\";\n\nfunction buildUrl(url: string, query?: HttpRequest[\"query\"]): string {\n  if (!query || Object.keys(query).length === 0) {\n    return url;\n  }\n\n  const searchParams = new URLSearchParams();\n  Object.entries(query).forEach(([key, value]) => {\n    if (value === undefined) return;\n    searchParams.append(key, String(value));\n  });\n  const qs = searchParams.toString();\n  return qs ? `${url}?${qs}` : url;\n}\n\nexport class FetchHttpClient implements HttpClient {\n  async send<T>(request: HttpRequest): Promise<HttpResponse<T>> {\n    const url = buildUrl(request.url, request.query);\n\n    let body: BodyInit | undefined;\n    if (typeof request.body === \"string\") {\n      body = request.body;\n    } else if (request.body instanceof URLSearchParams) {\n      body = request.body.toString();\n    } else if (request.body && typeof request.body === \"object\") {\n      body = JSON.stringify(request.body);\n    }\n\n    const response = await fetch(url, {\n      method: request.method,\n      headers: request.headers,\n      body: request.method === \"GET\" ? undefined : body,\n    });\n\n    const headers: Record<string, string> = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n\n    // Check content-type before parsing JSON\n    const contentType =\n      headers[\"content-type\"] || headers[\"Content-Type\"] || \"\";\n    const isJson =\n      contentType.includes(\"application/json\") ||\n      contentType.includes(\"text/json\");\n\n    // Read response as text first so we can provide better error messages\n    // and handle both JSON and non-JSON responses\n    const text = await response.text();\n\n    let data: T;\n\n    if (!response.ok) {\n      // For non-OK responses, provide detailed error information\n      throw new Error(\n        `HTTP ${response.status}: ${response.statusText}. Content-Type: ${contentType || \"unknown\"}. Response: ${text.substring(0, 500)}`,\n      );\n    }\n\n    if (isJson) {\n      try {\n        data = JSON.parse(text) as T;\n      } catch (error) {\n        throw new Error(\n          `Failed to parse JSON response. Status: ${response.status}, Content-Type: ${contentType}, Response preview: ${text.substring(0, 200)}`,\n        );\n      }\n    } else {\n      // If not marked as JSON but response is OK, try to parse anyway\n      // (some APIs don't set content-type correctly)\n      try {\n        data = JSON.parse(text) as T;\n      } catch {\n        throw new Error(\n          `Expected JSON response but received ${contentType || \"unknown content type\"}. Response preview: ${text.substring(0, 200)}`,\n        );\n      }\n    }\n\n    return {\n      status: response.status,\n      data,\n      headers,\n    };\n  }\n}\n","import type { ClientCredentialsConfig } from \"./types\";\nimport type { HttpClient, HttpResponse } from \"../http\";\nimport { TokenCache } from \"./token-cache\";\n\ninterface TokenResponse {\n  access_token: string;\n  expires_in: number;\n  token_type?: string;\n}\n\nconst DEFAULT_SCOPE = \"basic\";\n\nexport class ClientCredentialsAuthenticator {\n  constructor(\n    private readonly config: ClientCredentialsConfig,\n    private readonly http: HttpClient,\n    private readonly cache: TokenCache,\n  ) {}\n\n  async getAccessToken(): Promise<string> {\n    const cached = await this.cache.get();\n    if (cached) {\n      return cached.token;\n    }\n\n    const fresh = await this.fetchToken();\n    await this.cache.set(fresh.access_token, fresh.expires_in);\n    return fresh.access_token;\n  }\n\n  private async fetchToken(): Promise<TokenResponse> {\n    const tokenUrl = this.config.tokenUrl;\n    if (!tokenUrl) {\n      throw new Error(\"Client credentials tokenUrl is required\");\n    }\n\n    const scope = this.normalizeScopes(this.config.scopes);\n    const body = new URLSearchParams({\n      grant_type: \"client_credentials\",\n      scope,\n    });\n\n    const response: HttpResponse<TokenResponse> = await this.http.send({\n      method: \"POST\",\n      url: tokenUrl,\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n        Authorization: `Basic ${this.encodeCredentials()}`,\n      },\n      body,\n    });\n\n    if (response.status !== 200) {\n      throw new Error(`Failed to fetch access token: ${response.status}`);\n    }\n\n    if (!response.data?.access_token || !response.data?.expires_in) {\n      throw new Error(\"Malformed token response\");\n    }\n\n    return response.data;\n  }\n\n  private encodeCredentials(): string {\n    if (!this.config.clientId || !this.config.clientSecret) {\n      throw new Error(\"Client credentials require clientId and clientSecret\");\n    }\n    const credentials = `${this.config.clientId}:${this.config.clientSecret}`;\n    if (typeof Buffer !== \"undefined\") {\n      return Buffer.from(credentials, \"utf8\").toString(\"base64\");\n    }\n    if (typeof btoa === \"function\") {\n      return btoa(credentials);\n    }\n    throw new Error(\"No base64 encoder available for credentials\");\n  }\n\n  private normalizeScopes(scopes?: string | string[]): string {\n    if (!scopes || (Array.isArray(scopes) && scopes.length === 0)) {\n      return DEFAULT_SCOPE;\n    }\n    if (typeof scopes === \"string\") {\n      return scopes.trim() || DEFAULT_SCOPE;\n    }\n    return scopes.join(\" \");\n  }\n}\n\n","import type { StorageAdapter } from \"../platform\";\n\nexport interface CachedToken {\n  token: string;\n  expiresAt: number;\n}\n\nconst SAFETY_WINDOW_MS = 5_000;\n\nexport class TokenCache {\n  constructor(private readonly storage: StorageAdapter, private readonly key: string) {}\n\n  async get(): Promise<CachedToken | null> {\n    try {\n      const raw = await this.storage.getItem(this.key);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw) as CachedToken;\n      if (!parsed.token || !parsed.expiresAt) return null;\n      if (parsed.expiresAt <= Date.now()) {\n        await this.storage.removeItem(this.key);\n        return null;\n      }\n      return parsed;\n    } catch {\n      return null;\n    }\n  }\n\n  async set(token: string, expiresInSeconds: number): Promise<void> {\n    const expiresAt = Date.now() + expiresInSeconds * 1000 - SAFETY_WINDOW_MS;\n    const payload: CachedToken = { token, expiresAt };\n    await this.storage.setItem(this.key, JSON.stringify(payload));\n  }\n\n  async clear(): Promise<void> {\n    await this.storage.removeItem(this.key);\n  }\n}\n\n","import type { OAuth1Config } from \"./types\";\nimport type { CryptoAdapter } from \"../platform\";\n\nexport interface OAuth1Params {\n  oauth_consumer_key: string;\n  oauth_signature_method: string;\n  oauth_timestamp: string;\n  oauth_nonce: string;\n  oauth_version: string;\n  oauth_signature?: string;\n  oauth_token?: string;\n}\n\nexport interface OAuth1RequestConfig {\n  method: string;\n  url: string;\n  params?: Record<string, string>;\n}\n\nconst RFC3986_REGEX = /[!'()*]/g;\nconst RFC3986_REPLACEMENTS: Record<string, string> = {\n  \"!\": \"%21\",\n  \"'\": \"%27\",\n  \"(\": \"%28\",\n  \")\": \"%29\",\n  \"*\": \"%2A\",\n};\n\nexport class OAuth1Signer {\n  constructor(private readonly config: OAuth1Config, private readonly crypto: CryptoAdapter) {}\n\n  async generateParams(request: OAuth1RequestConfig): Promise<Record<string, string>> {\n    const oauthParams: OAuth1Params = {\n      oauth_consumer_key: this.config.consumerKey,\n      oauth_signature_method: \"HMAC-SHA1\",\n      oauth_timestamp: Math.floor(Date.now() / 1000).toString(),\n      oauth_nonce: await this.generateNonce(),\n      oauth_version: \"1.0\",\n    };\n\n    if (this.config.accessToken) {\n      oauthParams.oauth_token = this.config.accessToken;\n    }\n\n    const allParams: Record<string, string> = {\n      ...oauthParams,\n      ...(request.params ?? {}),\n    };\n\n    const signatureBaseString = this.createSignatureBaseString(request.method, request.url, allParams);\n    const signature = await this.sign(signatureBaseString);\n    oauthParams.oauth_signature = signature;\n\n    return {\n      ...oauthParams,\n      ...(request.params ?? {}),\n    };\n  }\n\n  buildAuthorizationHeader(params: Record<string, string>): string {\n    const headerParams = Object.entries(params)\n      .filter(([key]) => key.startsWith(\"oauth_\"))\n      .map(([key, value]) => `${key}=\"${percentEncode(value)}\"`)\n      .join(\", \");\n    return `OAuth ${headerParams}`;\n  }\n\n  private async generateNonce(): Promise<string> {\n    const bytes = await this.crypto.randomBytes(16);\n    return Array.from(bytes)\n      .map((byte) => byte.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n\n  private async sign(signatureBaseString: string): Promise<string> {\n    const key = `${percentEncode(this.config.consumerSecret)}&${percentEncode(\n      this.config.accessTokenSecret ?? \"\",\n    )}`;\n    return this.crypto.hmacSha1(key, signatureBaseString);\n  }\n\n  private createSignatureBaseString(method: string, url: string, params: Record<string, string>): string {\n    const encodedMethod = percentEncode(method.toUpperCase());\n    const encodedUrl = percentEncode(normalizeUrl(url));\n    const normalizedParams = normalizeParams(params);\n    return `${encodedMethod}&${encodedUrl}&${percentEncode(normalizedParams)}`;\n  }\n}\n\nfunction normalizeUrl(rawUrl: string): string {\n  const url = new URL(rawUrl);\n  const port = url.port || (url.protocol === \"https:\" ? \"443\" : \"80\");\n  const isDefaultPort = (url.protocol === \"https:\" && port === \"443\") || (url.protocol === \"http:\" && port === \"80\");\n  const host = isDefaultPort ? url.host.split(\":\")[0] : url.host;\n  return `${url.protocol}//${host}${url.pathname}`;\n}\n\nfunction normalizeParams(params: Record<string, string>): string {\n  return Object.keys(params)\n    .sort()\n    .map((key) => `${percentEncode(key)}=${percentEncode(params[key])}`)\n    .join(\"&\");\n}\n\nexport function percentEncode(value: string): string {\n  return encodeURIComponent(value).replace(RFC3986_REGEX, (char) => RFC3986_REPLACEMENTS[char]);\n}\n\n","import type { HttpClient, HttpMethod } from \"../http\";\nimport type { CryptoAdapter, PlatformAdapterBundle, StorageAdapter } from \"../platform\";\nimport type { SupportedAuthProvider } from \"./types\";\nimport { ClientCredentialsAuthenticator } from \"./client-credentials\";\nimport { TokenCache } from \"./token-cache\";\nimport { OAuth1Signer } from \"./oauth1\";\n\nexport interface AuthRequestContext {\n  method: HttpMethod;\n  url: string;\n  query?: Record<string, string>;\n}\n\nexport interface AuthResult {\n  headers?: Record<string, string>;\n  query?: Record<string, string>;\n}\n\nexport class AuthManager {\n  private clientCredentials?: ClientCredentialsAuthenticator;\n  private oauth1Signer?: OAuth1Signer;\n  private storage: StorageAdapter;\n  private crypto: CryptoAdapter;\n\n  constructor(\n    private readonly provider: SupportedAuthProvider,\n    private readonly http: HttpClient,\n    adapters: PlatformAdapterBundle,\n    defaultTokenUrl?: string,\n  ) {\n    this.storage = adapters.storage;\n    this.crypto = adapters.crypto;\n    if (provider.strategy === \"client-credentials\") {\n      if (!provider.config.tokenUrl && defaultTokenUrl) {\n        provider.config.tokenUrl = defaultTokenUrl;\n      }\n      const cacheKey = `fatsecret:access_token:${provider.config.clientId}`;\n      const cache = new TokenCache(this.storage, cacheKey);\n      this.clientCredentials = new ClientCredentialsAuthenticator(\n        provider.config,\n        this.http,\n        cache,\n      );\n      return;\n    }\n\n    this.oauth1Signer = new OAuth1Signer(provider.config, this.crypto);\n  }\n\n  async getAuth(context: AuthRequestContext): Promise<AuthResult> {\n    if (this.provider.strategy === \"client-credentials\") {\n      if (!this.clientCredentials) {\n        throw new Error(\"Client credentials authenticator not configured\");\n      }\n      const token = await this.clientCredentials.getAccessToken();\n      return {\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n      };\n    }\n\n    if (!this.oauth1Signer) {\n      throw new Error(\"OAuth1 signer not configured\");\n    }\n\n    const params = await this.oauth1Signer.generateParams({\n      method: context.method,\n      url: context.url,\n      params: context.query,\n    });\n\n    return {\n      query: params,\n      headers: {\n        Authorization: this.oauth1Signer.buildAuthorizationHeader(params),\n      },\n    };\n  }\n}\n\n","import type { HttpClient, HttpResponse, HttpMethod } from \"../http\";\nimport type { FatSecretEnvironment } from \"../config\";\nimport type { AuthManager } from \"../auth/auth-manager\";\nimport type { FatSecretMethod } from \"../types\";\n\ninterface ApiServiceOptions {\n  http: HttpClient;\n  environment: FatSecretEnvironment;\n  authManager: AuthManager;\n}\n\ntype QueryValue = string | number | boolean | undefined;\n\nexport class ApiService {\n  constructor(private readonly options: ApiServiceOptions) {}\n\n  async callMethod<TResponse>(\n    method: FatSecretMethod | string,\n    queryParams: Record<string, QueryValue> = {},\n  ): Promise<TResponse> {\n    const url = `${this.options.environment.apiBaseUrl}/server.api`;\n    const query = {\n      method: typeof method === \"string\" ? method : method,\n      format: \"json\",\n      ...queryParams,\n    };\n\n    const auth = await this.options.authManager.getAuth({\n      method: \"GET\",\n      url,\n      query: stringifyRecord(query),\n    });\n\n    const response = await this.sendRequest<TResponse>({\n      method: \"GET\",\n      url,\n      query: {\n        ...query,\n        ...(auth.query ?? {}),\n      },\n      headers: auth.headers,\n    });\n\n    return response;\n  }\n\n  async postJson<TResponse>(\n    url: string,\n    body: Record<string, unknown>,\n  ): Promise<TResponse> {\n    const auth = await this.options.authManager.getAuth({\n      method: \"POST\",\n      url,\n    });\n\n    return this.sendRequest<TResponse>({\n      method: \"POST\",\n      url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        ...(auth.headers ?? {}),\n      },\n      body,\n    });\n  }\n\n  private async sendRequest<T>({\n    method,\n    url,\n    query,\n    headers,\n    body,\n  }: {\n    method: HttpMethod;\n    url: string;\n    query?: Record<string, QueryValue>;\n    headers?: Record<string, string>;\n    body?: Record<string, unknown> | string | URLSearchParams;\n  }): Promise<T> {\n    const response: HttpResponse<T> = await this.options.http.send<T>({\n      method,\n      url,\n      query,\n      headers,\n      body,\n    });\n\n    if (response.status !== 200) {\n      throw new Error(`FatSecret API error: ${response.status}`);\n    }\n\n    const data = response.data;\n    if (isErrorPayload(data)) {\n      throw new Error(data.error.message ?? \"FatSecret API error\");\n    }\n    return data;\n  }\n}\n\nfunction stringifyRecord(\n  params: Record<string, QueryValue>,\n): Record<string, string> {\n  return Object.entries(params).reduce<Record<string, string>>(\n    (acc, [key, value]) => {\n      if (value === undefined) return acc;\n      acc[key] = String(value);\n      return acc;\n    },\n    {},\n  );\n}\n\nfunction isErrorPayload(\n  data: unknown,\n): data is { error: { message?: string } } {\n  return Boolean(\n    data &&\n      typeof data === \"object\" &&\n      \"error\" in (data as Record<string, unknown>),\n  );\n}\n","export enum FatSecretMethod {\n  FoodsSearchV3 = \"foods.search.v3\",\n  FoodFindIdForBarcode = \"food.find_id_for_barcode\",\n  FoodsAutocompleteV2 = \"foods.autocomplete.v2\",\n  FoodBrandsGetAllV2 = \"food_brands.get.v2\",\n  FoodCategoriesGetAllV2 = \"food_categories.get.v2\",\n  FoodSubCategoriesGetV2 = \"food_sub_categories.get.v2\",\n  RecipesGetByIdV2 = \"recipe.get.v2\",\n  RecipesSearchV3 = \"recipes.search.v3\",\n  RecipeTypesGetV2 = \"recipe_types.get.v2\",\n}\n\nexport enum FatSecretEndpoint {\n  NaturalLanguageProcessingV1 = \"/natural-language-processing/v1\",\n  ImageRecognitionV2 = \"/image-recognition/v2\",\n}\n","import type { HttpClient } from \"../http\";\nimport { detectPlatform } from \"../config/platform\";\nimport type {\n  PlatformAdapterBundle,\n  StorageAdapter,\n  CryptoAdapter,\n} from \"./types\";\n\nconst maybeBuffer = (): typeof Buffer | undefined =>\n  (globalThis as Record<string, unknown>).Buffer as typeof Buffer | undefined;\n\nclass MemoryStorageAdapter implements StorageAdapter {\n  private store = new Map<string, string>();\n\n  async getItem(key: string): Promise<string | null> {\n    return this.store.has(key) ? this.store.get(key)! : null;\n  }\n\n  async setItem(key: string, value: string): Promise<void> {\n    this.store.set(key, value);\n  }\n\n  async removeItem(key: string): Promise<void> {\n    this.store.delete(key);\n  }\n}\n\nclass BrowserStorageAdapter implements StorageAdapter {\n  async getItem(key: string): Promise<string | null> {\n    try {\n      return window.localStorage.getItem(key);\n    } catch {\n      return null;\n    }\n  }\n\n  async setItem(key: string, value: string): Promise<void> {\n    window.localStorage.setItem(key, value);\n  }\n\n  async removeItem(key: string): Promise<void> {\n    window.localStorage.removeItem(key);\n  }\n}\n\nclass NodeCryptoAdapter implements CryptoAdapter {\n  private async loadCrypto() {\n    return (await import(\"crypto\")).default;\n  }\n\n  async randomBytes(length: number): Promise<Uint8Array> {\n    const crypto = await this.loadCrypto();\n    return new Uint8Array(crypto.randomBytes(length));\n  }\n\n  async hmacSha1(key: string, baseString: string): Promise<string> {\n    const crypto = await this.loadCrypto();\n    return crypto.createHmac(\"sha1\", key).update(baseString).digest(\"base64\");\n  }\n\n  base64Encode(input: Uint8Array | string): string {\n    const buffer = maybeBuffer();\n    if (typeof input === \"string\") {\n      return buffer\n        ? buffer.from(input, \"utf8\").toString(\"base64\")\n        : btoa(input);\n    }\n    return buffer\n      ? buffer.from(input).toString(\"base64\")\n      : btoa(bytesToBinary(input));\n  }\n}\n\nclass WebCryptoAdapter implements CryptoAdapter {\n  constructor(private readonly crypto: Crypto) {}\n\n  async randomBytes(length: number): Promise<Uint8Array> {\n    const bytes = new Uint8Array(length);\n    this.crypto.getRandomValues(bytes);\n    return bytes;\n  }\n\n  async hmacSha1(key: string, baseString: string): Promise<string> {\n    const encoder = new TextEncoder();\n    const cryptoKey = await this.crypto.subtle.importKey(\n      \"raw\",\n      encoder.encode(key),\n      { name: \"HMAC\", hash: \"SHA-1\" },\n      false,\n      [\"sign\"],\n    );\n    const signature = await this.crypto.subtle.sign(\n      \"HMAC\",\n      cryptoKey,\n      encoder.encode(baseString),\n    );\n    return uint8ToBase64(new Uint8Array(signature));\n  }\n\n  base64Encode(input: Uint8Array | string): string {\n    if (typeof input === \"string\") {\n      return btoa(input);\n    }\n    return uint8ToBase64(input);\n  }\n}\n\nclass PlaceholderCryptoAdapter implements CryptoAdapter {\n  async randomBytes(length: number): Promise<Uint8Array> {\n    throw new Error(\n      `randomBytes(${length}) requires a platform crypto implementation`,\n    );\n  }\n\n  async hmacSha1(key: string, baseString: string): Promise<string> {\n    void key;\n    void baseString;\n    throw new Error(\"hmacSha1 requires a platform crypto implementation\");\n  }\n\n  base64Encode(input: Uint8Array | string): string {\n    const buffer = maybeBuffer();\n    if (typeof input === \"string\") {\n      if (typeof btoa === \"function\") return btoa(input);\n      if (buffer) return buffer.from(input, \"utf8\").toString(\"base64\");\n    } else if (buffer) {\n      return buffer.from(input).toString(\"base64\");\n    }\n    throw new Error(\"base64Encode requires Buffer or btoa support\");\n  }\n}\n\nexport const createMemoryStorageAdapter = (): StorageAdapter =>\n  new MemoryStorageAdapter();\n\nexport const createNodeAdapters = (): PlatformAdapterBundle => ({\n  target: \"node\",\n  storage: createMemoryStorageAdapter(),\n  crypto: new NodeCryptoAdapter(),\n});\n\nexport const createWebAdapters = (): PlatformAdapterBundle => {\n  if (typeof window === \"undefined\" || !window.crypto) {\n    throw new Error(\"Window crypto APIs are unavailable in this environment.\");\n  }\n  return {\n    target: \"web\",\n    storage: window.localStorage\n      ? new BrowserStorageAdapter()\n      : createMemoryStorageAdapter(),\n    crypto: new WebCryptoAdapter(window.crypto),\n  };\n};\n\nexport const createReactNativeAdapters = (options: {\n  storage: StorageAdapter;\n  crypto: CryptoAdapter;\n  httpClient?: HttpClient;\n}): PlatformAdapterBundle => ({\n  target: \"react-native\",\n  storage: options.storage,\n  crypto: options.crypto,\n  httpClient: options.httpClient,\n});\n\nexport const createDefaultPlatformAdapters = (): PlatformAdapterBundle => {\n  const platform = detectPlatform();\n  if (platform === \"web\") {\n    try {\n      return createWebAdapters();\n    } catch {\n      return {\n        target: \"web\",\n        storage: createMemoryStorageAdapter(),\n        crypto: new PlaceholderCryptoAdapter(),\n      };\n    }\n  }\n\n  if (platform === \"node\") {\n    return createNodeAdapters();\n  }\n\n  throw new Error(\n    \"React Native detected. Please provide platformAdapters explicitly via createReactNativeAdapters().\",\n  );\n};\n\nconst uint8ToBase64 = (bytes: Uint8Array): string => {\n  const buffer = maybeBuffer();\n  if (buffer) {\n    return buffer.from(bytes).toString(\"base64\");\n  }\n  return btoa(bytesToBinary(bytes));\n};\n\nconst bytesToBinary = (bytes: Uint8Array): string =>\n  Array.from(bytes)\n    .map((byte) => String.fromCharCode(byte))\n    .join(\"\");\n","import type { FatSecretEnvironment } from \"./config\";\nimport { DEFAULT_ENVIRONMENT } from \"./config\";\nimport type { HttpClient } from \"./http\";\nimport { FetchHttpClient } from \"./http\";\nimport type { SupportedAuthProvider, FatSecretAuthStrategy } from \"./auth\";\nimport { AuthManager } from \"./auth\";\nimport { ApiService } from \"./service/api-service\";\nimport {\n  type FoodSearchV3Request,\n  type FoodSearchV3Response,\n  type FoodFindIdForBarcodeRequest,\n  type FoodFindIdForBarcodeResponse,\n  type FoodGetByIdRequest,\n  type FoodGetByIdResponse,\n  type FoodAutoCompleteV2Request,\n  type FoodAutoCompleteV2Response,\n  type FoodBrandsGetAllV2Request,\n  type FoodBrandsGetAllV2Response,\n  type FoodCategoriesGetAllV2Request,\n  type FoodCategoriesGetAllV2Response,\n  type FoodSubCategoriesGetV2Request,\n  type FoodSubCategoriesGetV2Response,\n  type RecipeSearchRequest,\n  type RecipeSearchResponse,\n  type RecipeGetByIdRequest,\n  type RecipeGetByIdResponse,\n  type RecipeTypesResponse,\n  type NaturalLanguageProcessingRequest,\n  type NaturalLanguageProcessingResponse,\n  type ImageRecognitionRequest,\n  type ImageRecognitionResponse,\n  FatSecretMethod,\n} from \"./types\";\nimport type { PlatformAdapterBundle } from \"./platform\";\nimport { createDefaultPlatformAdapters } from \"./platform\";\n\nexport interface FatSecretClientOptions {\n  auth: SupportedAuthProvider;\n  environment?: FatSecretEnvironment;\n  httpClient?: HttpClient;\n  platformAdapters?: PlatformAdapterBundle;\n}\n\nexport type { FatSecretAuthStrategy } from \"./auth\";\n\nexport class FatSecretNutritionClient {\n  private readonly http: HttpClient;\n  private readonly env: FatSecretEnvironment;\n  private readonly adapters: PlatformAdapterBundle;\n  private readonly authManager: AuthManager;\n  private readonly apiService: ApiService;\n\n  constructor(private readonly options: FatSecretClientOptions) {\n    this.env = options.environment ?? DEFAULT_ENVIRONMENT;\n    this.http = options.httpClient ?? new FetchHttpClient();\n    this.adapters = options.platformAdapters ?? createDefaultPlatformAdapters();\n    this.authManager = new AuthManager(\n      options.auth,\n      this.http,\n      this.adapters,\n      this.env.oauthBaseUrl,\n    );\n    this.apiService = new ApiService({\n      http: this.http,\n      environment: this.env,\n      authManager: this.authManager,\n    });\n  }\n\n  get strategy(): FatSecretAuthStrategy {\n    return this.options.auth.strategy;\n  }\n\n  /**\n   * Mirrors Dart `search` (foods.search.v3).\n   */\n  async search(\n    props: FoodSearchV3Request,\n  ): Promise<FoodSearchV3Response | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<FoodSearchV3Response>(\n        FatSecretMethod.FoodsSearchV3,\n        this.toQuery(props),\n      ),\n    );\n  }\n\n  /**\n   * Mirrors Dart `getById` (food.get.v4).\n   */\n  async getById(\n    props: FoodGetByIdRequest,\n  ): Promise<FoodGetByIdResponse | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<FoodGetByIdResponse>(\n        \"food.get.v4\",\n        this.toQuery(props),\n      ),\n    );\n  }\n\n  async foodFindIdForBarcode(\n    props: FoodFindIdForBarcodeRequest,\n  ): Promise<FoodFindIdForBarcodeResponse | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<FoodFindIdForBarcodeResponse>(\n        FatSecretMethod.FoodFindIdForBarcode,\n        this.toQuery(props),\n      ),\n    );\n  }\n\n  async autoComplete(\n    props: FoodAutoCompleteV2Request,\n  ): Promise<FoodAutoCompleteV2Response | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<FoodAutoCompleteV2Response>(\n        FatSecretMethod.FoodsAutocompleteV2,\n        this.toQuery(props),\n      ),\n    );\n  }\n\n  async searchBrands(\n    props: FoodBrandsGetAllV2Request,\n  ): Promise<FoodBrandsGetAllV2Response | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<FoodBrandsGetAllV2Response>(\n        FatSecretMethod.FoodBrandsGetAllV2,\n        this.toQuery(props),\n      ),\n    );\n  }\n\n  async getFoodCategories(\n    props?: FoodCategoriesGetAllV2Request,\n  ): Promise<FoodCategoriesGetAllV2Response | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<FoodCategoriesGetAllV2Response>(\n        FatSecretMethod.FoodCategoriesGetAllV2,\n        this.toQuery(props ?? {}),\n      ),\n    );\n  }\n\n  async getFoodSubCategories(\n    props: FoodSubCategoriesGetV2Request,\n  ): Promise<FoodSubCategoriesGetV2Response | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<FoodSubCategoriesGetV2Response>(\n        FatSecretMethod.FoodSubCategoriesGetV2,\n        this.toQuery(props),\n      ),\n    );\n  }\n\n  async searchRecipes(\n    props: RecipeSearchRequest,\n  ): Promise<RecipeSearchResponse | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<RecipeSearchResponse>(\n        FatSecretMethod.RecipesSearchV3,\n        this.toQuery(props),\n      ),\n    );\n  }\n\n  async getRecipeById(\n    props: RecipeGetByIdRequest,\n  ): Promise<RecipeGetByIdResponse | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<RecipeGetByIdResponse>(\n        FatSecretMethod.RecipesGetByIdV2,\n        this.toQuery(props),\n      ),\n    );\n  }\n\n  async getRecipeTypes(): Promise<RecipeTypesResponse | null> {\n    return this.safeCall(() =>\n      this.apiService.callMethod<RecipeTypesResponse>(\n        FatSecretMethod.RecipeTypesGetV2,\n      ),\n    );\n  }\n\n  async processNaturalLanguage(\n    props: NaturalLanguageProcessingRequest,\n  ): Promise<NaturalLanguageProcessingResponse | null> {\n    return this.safeCall(() =>\n      this.apiService.postJson<NaturalLanguageProcessingResponse>(\n        this.env.naturalLanguageProcessingUrl,\n        this.toJson(props),\n      ),\n    );\n  }\n\n  async imageRecognitionV2(\n    props: ImageRecognitionRequest,\n  ): Promise<ImageRecognitionResponse | null> {\n    return this.safeCall(() =>\n      this.apiService.postJson<ImageRecognitionResponse>(\n        this.env.imageRecognitionUrl,\n        this.toJson(props),\n      ),\n    );\n  }\n\n  private async safeCall<T>(fn: () => Promise<T>): Promise<T | null> {\n    try {\n      return await fn();\n    } catch (error) {\n      // Always log errors in test environment or when silent mode is disabled\n      const isSilent = process.env.FATSECRET_TS_SILENT_ERRORS === \"1\";\n      const isTest =\n        process.env.NODE_ENV === \"test\" ||\n        process.env.JEST_WORKER_ID !== undefined;\n\n      if (!isSilent || isTest) {\n        const errorDetails =\n          error instanceof Error\n            ? {\n                message: error.message,\n                stack: error.stack,\n                name: error.name,\n              }\n            : { error };\n        console.error(\"FatSecret request failed:\", errorDetails);\n      }\n      return null;\n    }\n  }\n\n  private toQuery<T extends object>(\n    params: T | undefined,\n  ): Record<string, QueryValue> {\n    const source = (params ?? {}) as Record<string, QueryValue>;\n    return Object.entries(source).reduce<Record<string, QueryValue>>(\n      (acc, [key, value]) => {\n        if (value !== undefined) {\n          acc[key] = value as QueryValue;\n        }\n        return acc;\n      },\n      {},\n    );\n  }\n\n  private toJson<T extends object>(payload: T): Record<string, unknown> {\n    return { ...((payload ?? {}) as Record<string, unknown>) };\n  }\n}\n\ntype QueryValue = string | number | boolean | undefined;\n"]}